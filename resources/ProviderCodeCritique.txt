Provider Code Critique:

Design Critique:
The design of the program is good. The usage of the square pattern to add Edit View feature is a great design, and the GUI design is intuitive and user-friendly, especially for the utilization of radio buttons. However, we have feedback to improve the design. The main logic is scattered around in the Model. A shape object stores all of its own list of motions, and the model implementation does not have the knowledge of a shape’s list of motions. This causes implications in the provider’s view where the panel asks for Shape objects and calls Shape’s functions to get list of motions, while the EditorView asks for Model object and calls Model’s functions to modify a shape’s list of motions. This design may cause unwanted mutations of different parts of the model by different views and customers will easily get confused. It might be safer to move all logic into the model and let view and panel both have a read-only version of the model.

Implementation Critique:
Our provider’s code implements all required functions. They have a clear distinction between their interfaces and implementations. One good implementation worth to mention is the way they use the timer. They include the timer in their view instead of in the controller, unlike our group does, which reduces a lot of overheads when working with the start, pause, resume, and restart operations. However, their implementation did not cover all the edge cases. For instance, in their panel implementation, when displaying the animation at the given tick, they have not considered the case when the start time equals the end time, and that is why they are not able to correctly process and show the animations from the given input files. Also, the speed calculation is incorrect. They are skipping ticks to speed up an animation instead of changing the delay time for the timer. The providers should take a look at the Swing Timer library documentation to fix this issue. Our suggestion would be writing more test cases to try to cover all scenarios before start coding.

Documentation Critique:
They have really good documentation coverage. All interfaces, classes, and methods have required Javadoc. However, the naming of some of their methods is confusing. For example, in their AnimationPanel class, they named acceptTransformation() for setting the transformation, and getTransformation() in the EditorView class for setting the transformation. They should fill in the empty “@returns” in their interface methods documentation, which can be really helpful for the customer to understand what the methods are doing. Also, they have not clearly stated what features in their program are functioning and which are not. The good thing is that they are really responsible for answering our questions by replying to all our emails and providing additional information to us.

Design Limitation:
It is not so easy to add a new shape in their design, they need to add another concrete class to the Model section. Moreover, every time they add a new shape, they need to add a new case to each switch statement trying to distinguish different shapes. To improve, they may use a public enum class to list all supported shapes and only add to this list when a new shape is needed. They can replace all the switch statement with a line of code using this enum strategy.


